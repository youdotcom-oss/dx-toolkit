name: Reusable Package Publisher

on:
  workflow_call:
    inputs:
      npm_package_name:
        description: "NPM package name (e.g., @youdotcom-oss/mcp)"
        required: true
        type: string
      version:
        description: "Version to publish (e.g., 1.0.0)"
        required: true
        type: string
      next:
        description: "Next prerelease number (optional)"
        required: false
        type: string
    secrets:
      PUBLISH_TOKEN:
        description: "Token with permissions to push to protected branches"
        required: true
    outputs:
      version:
        description: "The published version"
        value: ${{ jobs.update-version.outputs.version }}
      is_prerelease:
        description: "Whether this is a prerelease"
        value: ${{ jobs.update-version.outputs.is_prerelease }}
      package_name:
        description: "The package name"
        value: ${{ jobs.update-version.outputs.package_name }}
      release_notes:
        description: "The release notes"
        value: ${{ jobs.create-release.outputs.release_notes }}

env:
  REPO_NAME: "dx-toolkit"

jobs:
  update-version:
    runs-on: ubuntu-latest
    name: Update Version
    permissions:
      contents: write
    outputs:
      version: ${{ steps.set_version.outputs.version }}
      is_prerelease: ${{ steps.set_version.outputs.is_prerelease }}
      package_name: ${{ steps.derive_package.outputs.package_name }}
      has_dependents: ${{ steps.check_dependents.outputs.has_dependents }}
      dependents: ${{ steps.check_dependents.outputs.dependents }}
    steps:
      - name: Validate inputs
        env:
          INPUT_VERSION: ${{ inputs.version }}
          INPUT_NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
        run: |
          # SECURITY: Validate all inputs before use to prevent injection
          # Using env vars instead of direct interpolation to prevent shell injection

          # Validate version format (semver with optional pre-release suffix)
          if ! echo "$INPUT_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-z0-9]+)?$'; then
            echo "::error::Invalid version format: $INPUT_VERSION"
            echo "::error::Expected: X.Y.Z or X.Y.Z-suffix (e.g., 1.0.0 or 1.0.0-beta)"
            exit 1
          fi

          # Validate npm package name format (@scope/package-name)
          if ! echo "$INPUT_NPM_PACKAGE_NAME" | grep -qE '^@[a-z0-9-]+/[a-z0-9-]+$'; then
            echo "::error::Invalid npm package name: $INPUT_NPM_PACKAGE_NAME"
            echo "::error::Expected: @scope/package-name (lowercase, hyphens allowed)"
            exit 1
          fi

          echo "âœ“ Input validation passed"

      - name: Set version
        id: set_version
        env:
          INPUT_VERSION: ${{ inputs.version }}
          INPUT_NEXT: ${{ inputs.next }}
          BRANCH_NAME: ${{ github.ref_name }}
          INPUT_NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
        run: |
          base_version="$INPUT_VERSION"
          next="$INPUT_NEXT"
          branch="$BRANCH_NAME"
          package_name="$INPUT_NPM_PACKAGE_NAME"

          # Auto-treat as prerelease if not on main branch
          if [[ "$branch" != "main" ]]; then
            echo "âš ï¸  Non-main branch detected: $branch"
            echo "âš ï¸  Automatically treating as prerelease"

            if [[ -n "$next" ]]; then
              # User provided next number
              echo "version=${base_version}-next.${next}" >> $GITHUB_OUTPUT
            else
              # Auto-increment: find highest next version for this base version
              echo "Finding highest next version for ${base_version}..."

              # Get all versions matching pattern from npm
              EXISTING_VERSIONS=$(npm view "$package_name" versions --json 2>/dev/null || echo "[]")

              # Validate we got valid JSON
              if ! echo "$EXISTING_VERSIONS" | jq empty 2>/dev/null; then
                echo "::warning::Could not fetch versions from npm, defaulting to next.1"
                NEXT_NUMBER=1
              else
                # Find highest next number for this base version
                # Use jq to safely extract and find max (prevents injection, no external commands)
                HIGHEST=$(printf '%s' "$EXISTING_VERSIONS" | jq -r --arg base "$base_version" '
                  [.[] | select(startswith($base + "-next.")) | ltrimstr($base + "-next.") | tonumber]
                  | max // empty
                ')

                if [[ -z "$HIGHEST" ]]; then
                  NEXT_NUMBER=1
                else
                  NEXT_NUMBER=$((HIGHEST + 1))
                fi
              fi

              echo "Next prerelease version: ${base_version}-next.${NEXT_NUMBER}"
              echo "version=${base_version}-next.${NEXT_NUMBER}" >> $GITHUB_OUTPUT
            fi
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          else
            # Main branch - honor next input
            if [[ -n "$next" ]]; then
              echo "version=${base_version}-next.${next}" >> $GITHUB_OUTPUT
              echo "is_prerelease=true" >> $GITHUB_OUTPUT
            else
              echo "version=${base_version}" >> $GITHUB_OUTPUT
              echo "is_prerelease=false" >> $GITHUB_OUTPUT
            fi
          fi
      - name: Validate input version
        env:
          VERSION: ${{ steps.set_version.outputs.version }}
        run: |
          version="$VERSION"

          # Check for 'v' prefix (common mistake)
          if [[ "$version" =~ ^v ]]; then
            echo "::error::Version should not include 'v' prefix"
            echo "::error::Enter '1.3.4' not 'v1.3.4'"
            echo "::error::The workflow will automatically add 'v' for Git tags"
            exit 1
          fi

          # Validate semver format (allows dots in prerelease suffix for formats like 1.0.0-next.1)
          if [[ ! "$version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)(-([a-zA-Z0-9._-]+))?$ ]]; then
            echo "::error::Version must have the format 'x.y.z' or 'x.y.z-<string>', where x, y, and z are numbers."
            exit 1
          fi

          echo "âœ… Version format validated: $version"
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.PUBLISH_TOKEN }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install

      - name: Configure Git
        env:
          GH_TOKEN: ${{ secrets.PUBLISH_TOKEN }}
          GIT_AUTHOR_NAME: ${{ github.actor }}
          GIT_AUTHOR_EMAIL: ${{ github.actor }}@users.noreply.github.com
        run: |
          git config user.name "$GIT_AUTHOR_NAME"
          git config user.email "$GIT_AUTHOR_EMAIL"

      - name: Derive package name
        id: derive_package
        env:
          NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
        run: |
          # SAFE: All inputs validated in "Validate inputs" step with strict regex
          # Derive package directory from npm package name
          # @youdotcom-oss/mcp -> mcp
          PACKAGE_NAME="${NPM_PACKAGE_NAME#@youdotcom-oss/}"

          # Validate package name extraction
          if [[ -z "$PACKAGE_NAME" ]] || [[ "$PACKAGE_NAME" == "$NPM_PACKAGE_NAME" ]]; then
            echo "::error::Failed to extract package name from $NPM_PACKAGE_NAME"
            echo "::error::Expected format: @youdotcom-oss/package-name"
            exit 1
          fi

          echo "package_name=${PACKAGE_NAME}" >> $GITHUB_OUTPUT

      - name: Update package.json version
        env:
          GH_TOKEN: ${{ secrets.PUBLISH_TOKEN }}
          VERSION: ${{ steps.set_version.outputs.version }}
          NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
          PACKAGE_NAME: ${{ steps.derive_package.outputs.package_name }}
          BRANCH_NAME: ${{ github.ref_name }}
        run: |
          PACKAGE_DIR="packages/${PACKAGE_NAME}"

          # Validate package directory exists
          if [[ ! -d "$PACKAGE_DIR" ]]; then
            echo "::error::Package directory not found: $PACKAGE_DIR"
            echo "::error::Extracted package name: $PACKAGE_NAME"
            exit 1
          fi

          # Update the package version using jq (more reliable than npm version for prerelease formats)
          cd "$PACKAGE_DIR"
          PKG_JSON="package.json"
          if ! jq --arg ver "$VERSION" '.version = $ver' "$PKG_JSON" > "${PKG_JSON}.tmp"; then
            echo "::error::Failed to update package.json version to $VERSION"
            exit 1
          fi
          mv "${PKG_JSON}.tmp" "$PKG_JSON"
          echo "Updated package.json version to $VERSION"
          cd ../..

          # Verify version sync BEFORE committing
          cd "$PACKAGE_DIR"
          PACKAGE_VERSION=$(jq -r '.version' package.json)

          # Validate versions match (both without 'v' prefix)
          if [[ "$PACKAGE_VERSION" != "$VERSION" ]]; then
            echo "::error::Version mismatch after version update!"
            echo "::error::package.json: $PACKAGE_VERSION"
            echo "::error::Expected: $VERSION"
            exit 1
          fi

          # Validate no 'v' prefix in package.json
          if [[ "$PACKAGE_VERSION" =~ ^v ]]; then
            echo "::error::package.json version should not have 'v' prefix"
            echo "::error::Found: $PACKAGE_VERSION"
            exit 1
          fi

          echo "âœ… Version verified: $PACKAGE_VERSION"
          echo "âœ… Git tag will be: ${PACKAGE_NAME}@v$PACKAGE_VERSION"
          cd ../..

          # Commit version change
          git add "${PACKAGE_DIR}/package.json"

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "::notice::No version changes to commit (already at ${PACKAGE_NAME}@v$VERSION)"
          else
            git commit -m "ci: publish ${PACKAGE_NAME} v$VERSION [skip ci]"
            git push origin "$BRANCH_NAME"
          fi

      - name: Check for dependent packages and plugins
        id: check_dependents
        env:
          NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
          PACKAGE_NAME: ${{ steps.derive_package.outputs.package_name }}
        run: |
          # Find packages and plugins that depend on this package
          echo "Checking for workspace packages and plugins that depend on ${NPM_PACKAGE_NAME}..."

          DEPENDENTS=""

          # Check packages/ directory
          for pkg_json in packages/*/package.json; do
            # Skip the package we just published
            if [[ "$pkg_json" == "packages/${PACKAGE_NAME}/package.json" ]]; then
              continue
            fi

            # Check if this package depends on the published package
            HAS_DEP=$(jq -e --arg pkg "${NPM_PACKAGE_NAME}" \
              '(.dependencies[$pkg] // .devDependencies[$pkg]) != null' \
              "$pkg_json" && echo "true" || echo "false")

            if [[ "$HAS_DEP" == "true" ]]; then
              PKG_NAME=$(jq -r '.name' "$pkg_json")
              CURRENT_VER=$(jq -r --arg pkg "${NPM_PACKAGE_NAME}" \
                '.dependencies[$pkg] // .devDependencies[$pkg]' "$pkg_json")
              DEP_TYPE=$(jq -r --arg pkg "${NPM_PACKAGE_NAME}" \
                'if .dependencies[$pkg] then "dependencies" else "devDependencies" end' "$pkg_json")

              if [[ -n "$DEPENDENTS" ]]; then
                DEPENDENTS="${DEPENDENTS}"$'\n'
              fi
              DEPENDENTS="${DEPENDENTS}- **${PKG_NAME}** (package): Currently using \`${CURRENT_VER}\` in ${DEP_TYPE}"
            fi
          done

          # Check plugins/ directory
          for pkg_json in plugins/*/package.json; do
            if [[ ! -f "$pkg_json" ]]; then
              continue
            fi

            # Check if this plugin depends on the published package
            HAS_DEP=$(jq -e --arg pkg "${NPM_PACKAGE_NAME}" \
              '(.dependencies[$pkg] // .devDependencies[$pkg]) != null' \
              "$pkg_json" && echo "true" || echo "false")

            if [[ "$HAS_DEP" == "true" ]]; then
              PLUGIN_DIR=$(dirname "$pkg_json")
              PLUGIN_NAME=$(basename "$PLUGIN_DIR")
              CURRENT_VER=$(jq -r --arg pkg "${NPM_PACKAGE_NAME}" \
                '.dependencies[$pkg] // .devDependencies[$pkg]' "$pkg_json")
              DEP_TYPE=$(jq -r --arg pkg "${NPM_PACKAGE_NAME}" \
                'if .dependencies[$pkg] then "dependencies" else "devDependencies" end' "$pkg_json")

              if [[ -n "$DEPENDENTS" ]]; then
                DEPENDENTS="${DEPENDENTS}"$'\n'
              fi
              DEPENDENTS="${DEPENDENTS}- **${PLUGIN_NAME}** (plugin): Currently using \`${CURRENT_VER}\` in ${DEP_TYPE}"
            fi
          done

          if [[ -n "$DEPENDENTS" ]]; then
            echo "has_dependents=true" >> $GITHUB_OUTPUT
            # Use heredoc to safely pass multiline string
            echo "dependents<<EOF" >> $GITHUB_OUTPUT
            echo "$DEPENDENTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "Found dependent packages/plugins:"
            echo "$DEPENDENTS"
          else
            echo "has_dependents=false" >> $GITHUB_OUTPUT
            echo "No dependent packages or plugins found"
          fi

  npm-publish:
    runs-on: ubuntu-latest
    name: Publish to NPM
    needs: [update-version]
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Setup Node.js (for NPM OIDC)
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          registry-url: https://registry.npmjs.org
          check-latest: true

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Build project
        working-directory: packages/${{ needs.update-version.outputs.package_name }}
        run: bun run build

      - name: Publish to NPM (Trusted Publishing)
        working-directory: packages/${{ needs.update-version.outputs.package_name }}
        env:
          IS_PRERELEASE: ${{ needs.update-version.outputs.is_prerelease }}
        run: |
          # NPM trusted publishing uses OIDC token automatically
          # Provenance attestations are generated automatically (no --provenance flag needed)
          # No need to configure .npmrc or NPM_TOKEN

          if [[ "$IS_PRERELEASE" == "true" ]]; then
            echo "Publishing as next (prerelease)"
            npm publish --access public --tag next
          else
            echo "Publishing as latest (stable)"
            npm publish --access public
          fi

  create-release:
    runs-on: ubuntu-latest
    name: Create GitHub Release
    needs: [update-version, npm-publish]
    permissions:
      contents: write
    outputs:
      release_notes: ${{ steps.release.outputs.release_notes }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Create GitHub Release
        id: release
        env:
          GH_TOKEN: ${{ secrets.PUBLISH_TOKEN }}
          VERSION: ${{ needs.update-version.outputs.version }}
          PACKAGE_NAME: ${{ needs.update-version.outputs.package_name }}
          IS_PRERELEASE: ${{ needs.update-version.outputs.is_prerelease }}
        run: |
          # Use monorepo tag format: package@version
          TAG="${PACKAGE_NAME}@v${VERSION}"
          TITLE="${PACKAGE_NAME} v${VERSION}"

          if [[ "$IS_PRERELEASE" == "true" ]]; then
            gh release create "${TAG}" \
              --title "${TITLE}" \
              --generate-notes \
              --prerelease
          else
            gh release create "${TAG}" \
              --title "${TITLE}" \
              --generate-notes
          fi

          # Get the release notes
          RELEASE_NOTES=$(gh release view "${TAG}" --json body --jq '.body')
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  create-dependency-update-issue:
    if: needs.update-version.outputs.has_dependents == 'true'
    runs-on: ubuntu-latest
    name: Create Dependency Update Issue
    needs: [update-version, npm-publish, create-release]
    permissions:
      contents: read
      issues: write
    steps:
      - uses: actions/checkout@v4

      - name: Create dependency update issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSION: ${{ needs.update-version.outputs.version }}
          PACKAGE_NAME: ${{ needs.update-version.outputs.package_name }}
          NPM_PACKAGE_NAME: ${{ inputs.npm_package_name }}
          IS_PRERELEASE: ${{ needs.update-version.outputs.is_prerelease }}
          DEPENDENTS: ${{ needs.update-version.outputs.dependents }}
        run: |
          # Create issue body with dependency update instructions
          cat > issue_body.md << 'EOF'
## ðŸ“¦ Dependency Update Required

Successfully published **${{ env.NPM_PACKAGE_NAME }}@${{ env.VERSION }}**

### Packages and Plugins That Depend on This Package

${{ env.DEPENDENTS }}

### Action Required

Review the changes in this release and update dependent packages/plugins:

1. **Review Changes**: Check the [release notes](${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ env.PACKAGE_NAME }}@v${{ env.VERSION }})
2. **Test Compatibility**: Verify dependent packages work with the new version
3. **Update Dependencies**: Update `package.json` files in dependent packages/plugins
4. **Publish Updates**: Release new versions of affected packages

### For Prerelease Testing

EOF

          if [[ "$IS_PRERELEASE" == "true" ]]; then
            cat >> issue_body.md << 'EOF'
This is a **prerelease** version. Consider publishing coordinated prereleases for testing:

```bash
# Example: Test ai-sdk-plugin with mcp prerelease
# 1. Update packages/ai-sdk-plugin/package.json dependency
# 2. Test locally: cd packages/ai-sdk-plugin && bun test
# 3. Publish prerelease: trigger workflow with next parameter
```

Once testing is complete and ready for stable release, update to this version and publish stable releases.

EOF
          else
            cat >> issue_body.md << 'EOF'
This is a **stable release**. Update dependent packages to this version:

```bash
# Example: Update ai-sdk-plugin to use mcp@${{ env.VERSION }}
# 1. Edit packages/ai-sdk-plugin/package.json
# 2. Change "@youdotcom-oss/mcp": "${{ env.VERSION }}"
# 3. Test: cd packages/ai-sdk-plugin && bun test
# 4. Commit: git add . && git commit -m "chore: update mcp to ${{ env.VERSION }}"
# 5. Publish: trigger publish-ai-sdk-plugin workflow
```

EOF
          fi

          cat >> issue_body.md << 'EOF'
### Checklist

- [ ] Review release notes and changes
- [ ] Test dependent packages with new version locally
- [ ] Update package.json files with new version (exact version, no `^` or `~`)
- [ ] Run tests for dependent packages
- [ ] Publish updated packages (patch/minor version bump)
- [ ] Close this issue

---

ðŸ¤– *This issue was automatically created by the publish workflow*
EOF

          # Create the issue
          gh issue create \
            --title "Update dependencies on ${NPM_PACKAGE_NAME}@${VERSION}" \
            --label "dependencies" \
            --label "maintenance" \
            --body-file issue_body.md

          echo "âœ… Created dependency update issue"
